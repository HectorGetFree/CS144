lab0-4参考[b站阿苏EEer](https://www.bilibili.com/video/BV1v14y1s7oq?t=9.8)

lab5-7参考[kiprey](https://kiprey.github.io/tags/CS144/)

## Lab 2 

第一部分 `unwrap` 思路参考 [doraemonzzz](http://doraemonzzz.com/2021/12/27/2021-12-27-CS144-Lab2/) 但是注意这句代码 

`uint64_t r3 = checkpoint - (diff - (1ll << 32));`

原博客写的是 `uint64_t r3 = checkpoint - (diff + (1ll << 32));` 我觉得跟他的分析对不上，所以改了，发现，两种都可以通过测试，只能说测试样例一般般惹

## Lab 4

​	lab4 没有通过所有的测试，但是自己也不会修

## Lab 5

​	[reference: kiprey](https://kiprey.github.io/2021/11/cs144-lab5/) 

​	TCP 数据段可以包含在用户数据报的有效载荷中。在正常（用户空间）环境下，这是最容易实现的：Linux 提供了一个接口（“数据报套接字”，UDPSocket），允许应用程序仅提供用户数据报的有效载荷和目标地址，而内核负责构建 UDP 报头、IP 报头和以太网报头，然后将数据包发送到合适的下一跳。内核确保每个套接字都拥有唯一的本地和远程地址及端口号组合，并且由于内核将这些内容写入 UDP 和 IP 报头，因此可以保证不同应用程序之间的隔离。

​	在常见用法中，TCP 段几乎总是直接放在互联网数据报内，IP 报头和 TCP 报头之间没有 UDP 报头。这就是人们所说的“TCP/IP”。但这在实现上稍微困难一些。Linux 提供了一个称为 TUN 设备的接口，允许应用程序提供完整的互联网数据报，而内核负责其余部分（编写以太网报头，并通过物理以太网卡实际发送等）。但现在应用程序必须自己构建完整的 IP 报头，而不仅仅是有效载荷。

​	这些功能由网络接口执行：==该组件负责将出站 IP 数据报转换为链路层（例如以太网）帧，反之亦然==。（在实际系统中，网络接口通常具有类似 eth0、eth1、wlan0 等名称。）在本周的实验中，您将实现一个网络接口，并将其置于 TCP/IP 堆栈的最底层。您的代码将生成原始以太网帧，这些帧将通过称为 TAP 设备的接口移交给 Linux。TAP 设备类似于 TUN 设备，但级别更低，因为它交换的是原始链路层帧而不是 IP 数据报。

​	==大部分工作是查找（并缓存）每个下一跳 IP 地址的以太网地址。用于此目的的协议称为地址解析协议 (ARP)==。

​	该映射是一个缓存，或者说“软状态”：NetworkInterface 出于效率考虑会保留它，但如果必须从头重新启动，则该映射将自然重新生成，而不会造成问题。

## Lab 6

	在本周的实验中，你将在现有的 NetworkInterface 之上实现一个 IP 路由器。
路由器有多个网络接口，可以在其中任何一个接口上接收互联网数据报。
路由器的工作是根据路由表转发收到的数据报：路由表是一份规则列表，它告诉路由器，对于任何给定的数据报，

• 发送接口
• 下一跳的 IP 地址

​	你的任务是实现一个路由器，让它能够为任何给定的数据报找出这两个关键点。你不需要实现构成路由表的算法，例如 RIP、OSPF、
BGP 或 SDN 控制器——只需实现遵循路由表的算法即可。

​	您的路由器实现将使用 Sponge 库和一个新的 Router 类，并进行一些测试以检查路由器在模拟网络中的功能。实验 6 基于您在实验 5 中实现的 NetworkInterface，但不使用您在实验 0-4 中实现的 TCP 协议栈。IP 路由器不需要了解任何有关 TCP、ARP 或以太网（仅 IP）的知识。我们预计您的实现大约需要 25-30 行代码。

​	在本实验中，你将实现一个 Router 类，该类可以：

• 跟踪路由表（转发规则列表，或称路由）；
• 将收到的每个数据报转发至：

正确的下一跳；
– 正确的传出 NetworkInterface。

​	路由是一种“匹配-操作”规则：它告诉路由器，如果数据报发往
特定网络（IP 地址范围），并且该路由被选为最具体的匹配路由，则路由器应该将数据报转发到特定接口上的特定下一跳。
​	“匹配”：数据报是否发往此网络？路由前缀和前缀长度共同指定了可能包含数据报目的地的 IP 地址范围（网络）。路由前缀是一个 32 位数字 IP 地址。前缀长度是一个介于 0 到 32（含）之间的数字；它告诉路由器路由前缀中有多少个最高有效位是有效的。例如，要表达一条到网络“18.47.0.0/16”的路由（该路由匹配任何前两个字节为 18 和 47 的 32 位 IP 地址），路由前缀应为 305070080（18 × 2^24^ + 47 × 2^16^），前缀长度应为 16。任何发往“18.47.x.y”的数据报都将匹配。
​	“操作”：如果路由匹配并被选中，则执行的操作。如果路由器直接连接到相关网络，则下一跳将为空的可选项。
在这种情况下，下一跳是数据报的目标地址。但如果路由器通过其他路由器连接到相关网络，则下一跳将包含路径上下一个路由器的 IP 地址。接口编号给出了路由器网络接口的索引，该接口用于将数据报发送到下一跳。您可以使用该方法访问此接口。

​	这就是关键所在。此方法需要将一个数据报路由到下一跳，并通过相应的接口发出。它需要实现 IP 路由器的“最长前缀匹配”逻辑，以找到最佳路由。这意味着：

• 路由器搜索路由表，查找与数据报目标地址匹配的路由。“匹配”是指目标地址的前缀长度最高有效位与路由前缀的前缀长度最高有效位相同。
• 在匹配的路由中，路由器选择前缀长度值最大的路由。这就是最长前缀匹配路由。
• 如果没有匹配的路由，路由器将丢弃该数据报。
• 路由器减少数据报的 TTL（生存时间）。如果 TTL 已经为零，
或者在减少后达到零，路由器应该丢弃该数据报。
• 否则，路由器将修改后的数据报通过适当的接口（interface(interface num).send datagram()）发送到适当的下一跳。

​	互联网的设计中有一个巧妙之处（或者至少是一个成功的抽象）：路由器从不考虑 TCP、ARP 或以太网帧。路由器甚至不知道链路层是什么样子。路由器只考虑互联网数据报，并且只通过 NetworkInterface 抽象与链路层交互。对于诸如“链路层地址是如何解析的？”、

“链路层是否有自己不同于 IP 的寻址方案？”、
“链路层帧的格式是什么？”、
“数据报的有效载荷是什么意思？”之类的问题，路由器根本不在乎。